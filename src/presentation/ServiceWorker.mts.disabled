import pkg from '../../package.json' with { type: 'json' }
import { HandleEvent } from './HandleEvent.mjs';

const { version } = pkg as { version: string }

declare const self: ServiceWorkerGlobalScope;

new class ServiceWorker extends HandleEvent(EventTarget) {
    /**
     * The name of the cache
     */
    static get cacheName(): string { return `v${version}` }

    constructor() {
        super();
        ['activate', 'fetch', 'install'].forEach((eventName) => {
            self.addEventListener(eventName, this)
        })
    }

    /**
     * Perform a cache request. If the cache request fails, perform a network request.
     */
    protected async _fromCache(request: Request): Promise<Response> {
        const cache = await caches.open(ServiceWorker.cacheName),
            response = await cache.match(request) ?? await this._fromNetwork(request)

        if (response.status === 404)
            return (await cache.match('/'))!;

        return response
    }

    /**
     * Perform a network request and cache the response.
     */
    protected async _fromNetwork(request: Request): Promise<Response> {
        const [response, cache] = await Promise.all([
            fetch(request),
            caches.open(ServiceWorker.cacheName)
        ])
        if (!response.ok)
            throw new Error(response.statusText)
        cache.put(request, response.clone())

        return response
    }

    onInstall(event: ExtendableEvent) {
        event.waitUntil(self.skipWaiting())
    }

    onActivate(event: ExtendableEvent) {
        event.waitUntil(self.clients.claim())
    }

    onFetch(event: FetchEvent) {
        const request = event.request

        if (request.method !== 'GET')
            return

        const url = new URL(request.url)
        if (url.origin !== location.origin)
            return

        return event.respondWith(this._fromCache(request))
    }
}

export { }